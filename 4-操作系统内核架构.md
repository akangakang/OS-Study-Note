# 操作系统内核架构

**策略与机制分离**

* 策略（Policy）：要做什么 —— 相对动态

* 机制（Mechanism）：怎么做 —— 相对静态

## 1. 宏内核

### 1.1 宏内核的优缺点分析

**优点**

* 宏内核拥有丰富的沉淀和积累
  * 拥有巨大的统一的社区和生态
  * 针对不同场景优化了30年

**缺点**

* 宏内核的结构性缺陷
  * <u>安全性与可靠性问题</u>：模块之间没有很强的隔离机制
  * <u>实时性支持</u>：系统太复杂导致无法做最坏情况时延分析
  * 系统过于庞大而<u>阻碍了创新</u>：Linux代码行数已经过2千万

​	

### 1.2 宏内核难以满足的场景

* 向上向下的扩展 
  * 很难去剪裁/扩展一个宏内核系统支持从KB级别到TB级别的场景 
* 硬件异构性 
  * 很难长期支持一些定制化的方式去解决一些特定问题 
* 功能安全
  * 一个广泛共识：Linux无法通过汽车安全完整性认证（ASIL-D）
* 信息安全
  * 单点错误会导致整个系统出错，而现在有数百个安全问题（CVE）
* 确定性时延
  * Linux花费10+年合并实时补丁，目前依然不确定是否能支持确定性时延



## 2. 微内核

### 2.1 微内核的优缺点分析

**缺点**

1. 性能较差：内核中的模块交互由函数调用变成了进程间通信
2. 生态欠缺：尚未形成像Linux一样具有广泛开发者的社区
3. 重用问题：重用宏内核操作系统提供兼容性，带来新问题



## 3. 外核+库OS（EXOKERNEL + LIBOS）

**Exokernel 不提供硬件抽象**

* "只要内核提供抽象，就不能实现性能最大化"
* 只有应用才知道最适合的抽象（end-to-end原则）

**Exokernel 不管理资源，只管理应用**

* 负责将计算资源与应用的绑定，以及资源的回收
* 保证多个应用之间的隔离



### 库OS（LibOS）

* 策略与机制分离：将对硬件的抽象以库的形式提供 

* 高度定制化：不同应用可使用不同的LibOS，或完全自定义

* 更高性能：LibOS与应用其他代码之间通过<u>函数</u>调用直接交互



### Exokernel架构的设计

* **外核的功能** 
  * 追踪计算资源的拥有权 
  * 保证资源的保护
  * 回收对资源的访问权

* **对应的三个技术** 
  * 安全绑定（Secure binding）
  * 显式回收（Visible revocation）
  * 中止协议（Abort protocol）

<u>管理与保护分离</u>



### Exokernel架构的优缺点分析

**优点**

1. OS无抽象，能在理论上提供最优性能
2. 应用对计算有更精确的实时等控制
3. LibOS在用户态更易调试，调试周期更短
4. 可以按照应用领域的特点和需求，动态组装成最适合该应用领域的`LibOS`，最小化非必要代码，从而获得更高性能
5. 处于硬件特权级的操作系统内核可以做到非常小，并且由于多个`LibOS`之间的强隔离性，从而可以提升安全性和可靠性

**缺点**

1. 对计算资源的利用效率主要由应用决定
2. 定制化过多，导致维护难度增加



### 外核和微内核的区别

1. 外核架构将多个硬件资源切分长一个个切片，每个切片中保护的多个硬件资源由`LibOS`管理并直接服务于一个应用。而微内核架构则是通过让一个操作系统模块独立地运行在一个地址空间上来管理一个具体的硬件资源，为操作系统中的所有应用服务。
2. 外核架构中，运行在特权级的内核主要为`LibOS`提供硬件的多路复用能力，并管理`LibOS`。而微内核架构中，内核主要提供进程间通信的功能
3. 外核架构在面向一个功能和生态受限的场景下，可通过定制化`LibOS`获得更高的性能。微内核需要更复杂的优化。



## 4. 多内核架构(Multikernel)

### 背景：多核与异构

1. OS内部维护很多共享状态
   * Cache一致性的保证越来越难
   * 可扩展性非常差，核数增多，性能不升反降
2. GPU等设备越来越多
   * 设备本身越来越智能——设备有自己的CPU
   * 通过PCIe连接，主CPU与设备CPU之间通信非常慢
   * 通过系统总线连接，异构SoC（System on Chip）



### Multikernel的设计

**Multikernel的思路**

1. 默认的状态是划分而不是共享
2. 维持多份状态的copy而不是共享一份状态
3. 显式的核间通信机制(避免处理器核之间通过共享内存进行隐式的共享)

**Multikernel的设计**

1. 在每个core上运行一个小内核
2. OS整体是一个分布式系统
3. 应用程序依然运行在OS之上