# 硬件结构

## 1. 冯诺依曼架构

<img src="图片\冯诺依曼架构.png" alt="冯诺依曼架构" style="zoom:67%;" />

**冯诺依曼架构**：

* 中央处理单元CPU ：负责运算和逻辑控制
* 存储器：负责存储程序和数据，保存程序执行后的中间结果和最终结果
* 输入输出：与外界交互

**缺点**：

1. CPU与内存的交互引起的内存墙问题 
2. 据与指令不区分，指令等数据或数据等指令 
3. 串行顺序处理，缺乏数据并行能力



## 2. ARM

### 2.1 名词解释

* `ARM`指的是处理器(与`intel`相对)
* 现在广泛使用的是`ARMv8`的体系结构（不止指处理器还包括指令集什么的）
* `ARMv8`体系结构的主要特点是支持64位虚拟地址 （`ARMv7`只支持32位）
* `ARMv8`支持`AArch64`和`AArch32`(与`x86`,`x86-64`相对)



### 2.2 `AArch64`实现

#### 寄存器

* 31个64位通用寄存器 ：`X0`-`X30`
  * `x29`用作帧指针(FP)，保存函数调用栈顶地址
  * `x30`用作链接指针(LP)，CPU在执行函数调用指令`bl`的时候会自动把返回地址保存其中
* 1个PC寄存器 
* 4个栈寄存器（切换时保存SP） : `SP_EL0`, `SP_EL1`, `SP_EL2`, `SP_EL3`
* 3个异常链接寄存器（保存异常的返回地址） – `ELR_EL1`, `ELR_EL2`, `ELR_EL3 `
* 3个程序状态寄存器（切换时保存`PSTATE`） – `SPSR_EL1`, `SPSR_EL2`, `SPSR_EL3`

* 页表基地址寄存器：`TTBR0_EL1`,`TTBR1_EL1`
  * `TTBR0_EL1`负责$0-2^{48}$
  
  * `TTBR1_EL1`负责$2^{48}-2^{64}$
  
    <img src="图片\内存空间.png" alt="内存空间" style="zoom:60%;" />



与`x86-64`对比：

* 16个通用寄存器
* 一个`rip`寄存器
* 一个栈寄存器（`rsp`）（切换特权级`rsp`压栈）
* 没有异常链接寄存器，把返回地址压栈
* 用`EFLAG`保存状态



> 问题：
>
> AArch64的TTBR0支持(0~2^48-1)的地址映射， TTBR1支持(2^48~2^64)的地址映射，这样的硬件设 计与x86-64中的CR3相比较，能够如何协助到操作系 统的设计？



#### 指令集

![risc-cisc](图片\risc-cisc.png)



#### 特权级

##### `X86-64`:

![特权级x86](图片\特权级x86.png)

##### `ARM`

* `EL0`:用户态程序
* `EL1`:内核态，操作系统运行
* `EL2`:hypervisor
* `EL3`:和安全特性`TrustZone`相关



**从`EL0`切换到`EL1`的三种情况：**

1. 系统调用，`svc`指令
2. 应用程序执行到一条指令，该指令触发了**异常**，该异常导致特权级切换（如缺页异常）
3. CPU收到外设的**中断**

**从`EL0`切换到`EL1`的基本流程：**

1. 正常执行
2. CPU发生中断或异常 
3. 保存处理器状态和错误信息至寄存器
4. 查询异常向量表并选择handler
5. 处理
6. 从handler中返回
7. 继续回到EL0执行

**CPU保存的状态主要有：**

1. 把当前`PC`存在`ELR_EL1`(exception link register) (存储触发异常的指令地址)
2. 异常原因存储在`ESR_EL1`(exception syndrome register)(比如是由于svc还是缺页)
3. 栈指针：从`SP_EL0`切换到`SP_EL1`
4. 其他状态：
   * 把CPU相关状态保存在`SPSR_EL1` (saved program status register)
   * 把引发缺页异常的地址存在`FAR_EL1`



#### 输入输出

**MMIO (Memory-mapped IO)** 

* 将设备映射到连续的物理内存中，使用相同的指令
* 如，Raspi3映射到0x3F200000 
* 行为与内存不完全一样，读写会有副作用（回忆volatile）

**PIO (Port IO)** 

* IO设备具有独立的地址空间 
* 使用特殊的指令（如x86中的in/out指令）





