# 文件系统

## 1. Ext2



![ext2文件系统](图片\ext2文件系统.png)

**超级块**：记录整个文件系统的元数据，如文件系统类型，版本等

**块分配信息**：使用`bitmap`的格式记录数据区中各个块的使用情况。一个`bit`代表一个块，表示该块有没有被分配

**inode分配信息**：记录`inode`的使用情况，一个`bit`表示一个`inode`，表示该`inode`有没有被分配

**inode表**：用数组的结构保存了整个文件系统所有的`inode`，`inode`号就是数组索引。一个`inode`对应一个文件，记录了这个文件的数据存储在哪些块里

### 1.1 inode

<img src="\图片\inode.png" alt="inode" style="zoom:67%;" />

**元数据**：文件类型，文件大小 ，链接数，文件权限，拥有用户/组，时间（创建、修改、访问时间）

**数据块指针**：12个直接指针，1个间接指针，1个二级间接指针，1个三级简介指针



### 1.2 硬链接

创建一个硬链接，不会新建一个`inode`

找到目标链接文件的`inode`后，在目标路径的父路径下，创建一个指向次`inode`的新目录项

### 1.3 符号链接

创建一个符号链接，会创建一个新的`inode`

创建一个新的文件，文件的内容是到目标链接文件的文件路径



## 2. Ext4文件存储 – 区段树（Extent）

> 问题：在Ext2的设计中，保存一个1GB的视频文件，文件被拆成多少数 据块？需要多少元数据来维护这些数据块？

$$
\begin{align}
数据块数:& \frac{10^6 KB}{4} \\
元数据的大小:& \frac{10^6 KB}{4} * 8Byte(一个指针) = 2M
\end{align}
$$

▲ 如果这些数据块物理上连续，只需要保存起始块地址和长度即可！

**区段（Extent）**：是由物理上连续的多个数据块组成

* 一个区段内的数据可以连续访问，无需按4KB数据块访问
* 可以减少元数据的数量

![区段树](图片\区段树.png)

**为什么这样设计**：

硬盘耗时在于最后读文件，前面内存操作耗时没关系



## 3. 文件内存映射：用mmap()来访问文件

mmap可将文件映射到虚拟内存空间中 

1. mmap时分配虚拟地址，<u>并标记此段虚拟地址与该文件的inode绑定</u> 
2. 访问mmap返回的虚拟地址时，触发缺页中断（page fault）
3. 缺页中断处理函数，<u>通过虚拟地址，找到该文件的inode</u>
4. 从磁盘中将inode中对应的数据读到内存页中 
5. <u>将内存页映射添加到页表中</u>

![mmap](图片\mmap.png)

**优势**：

* 对于随机访问，不用频繁lseek （syscall）
* 减少系统调用次数 
* 可以减少数据copy – 如拷贝文件，数据无需经过中间buffer 
* 访问的局部性更好
* 可以用madvice为内核提供访问提示，提高性能



把文件映射到虚拟内存，访问文件就像访问数组一样方便

![mmap](图片\mmap1.png)

## 4. 基于TABLE的文件系统

### 4.1 FAT

![fat1](图片\fat1.png)

#### FAT

**FAT**其实就是一个大数组，每一个簇（类似于block）都在FAT里对应了一个数组项

该数组项的内容是下一个簇号，也就比如FAT[i]=j，说明簇i后面的数据就是簇j

十六进制的全F表示这是最后一个簇

构成了链表

**目录项**

目录项里存了：数据的起始簇号，文件名，文件大小，属性（只读，隐藏，子目录，系统文件，卷标等）

> 为什么FAT在目录项里区分了文件时目录还是普通文件，inode文件系统并没有在目录项里区分

因为在inode里面记录了是目录还是普通文件，但是FAT表里不能记录这些信息，所以只能记载目录项里

**根文件夹**

第一个数据块



![fat2](图片\fat2.png)



> 为什么FAT不支持4G以上的文件

因为目录项里记录了文件大小(<u>单位为KB?</u>)，有4个字节
$$
4 byte=32bit\\
2^{32} = 4G
$$

> 为什么U盘一般用FAT

> 为什么FAT不支持link

如果要支持link，需要记录文件的`ref_cnt`

放哪呢？

放目录项：不行这样会有多个

放FAT：没地方->每个FAT都要加，若加上浪费空间

> 为什么FAT的随机读取文件非常慢

因为访问一个文件的中间部分，FAT文件系统不得不逐个簇进行查找，使得访问变慢



### 4.2 NTFS

![ntfs1](图片\ntfs1.png)

#### MFT

MFT记录了保存了前十六个元数据文件的位置

MFT也记录了MFT元数据文件的位置，该文件记录了其他所有文件的位置和信息

文件所有的信息都在MFT里面，所以everything找文件超级快

#### NTFS数据保存位置和目录项

* 非常驻文件（大文件/目录）
  * 数据区的B+树和区段 
* 常驻文件（小文件/目录） 
  * 大小不超过MFT记录的最大值（1KB）
  * 内嵌在MFT中保存（在数据属性中）
* 目录项 – 包含文件名、文件ID（在MFT中的序号）



## 5. 虚拟文件系统（VFS）

* FAT没有inode，如何挂载到VFS？ 
  * VFS层对上提供的接口，每个文件都有一个inode 
  * FAT的inode从哪里来？ 
* FAT的驱动需要提供inode 
  * 磁盘上的FAT并没有inode：硬盘上的数据结构
  * 内存中的VFS需要inode：只在内存中的数据结构

## 6. 存储结构与缓存

![存储结构与缓存](图片\存储结构与缓存.png)

## 7. 文件系统高级功能

### 7.1 文件复制

只复制inode(COW)

![文件复制](图片\文件复制.png)

### 7.2 快照（Snapshot）

* 同样使用CoW
* 对于基于inode表的文件系统 
  * 将inode表拷贝一份作为快照保存 
  * 标记已用数据区为CoW 
* 对于树状结构的文件系统 
  * 将树根拷贝一份作为快照保存
  * 树根以下的节点标记为CoW



### 7.3 稀疏文件

* 一个文件大部分数据为0，则为稀疏文件 – 如虚拟机镜像文件
* 稀疏文件中大量的0数据，白白消耗空间

* 在索引中增加标记
* 删除全0块



## 8. GIT：内容寻址文件系统

* 表面上GIT是一个版本控制软件 
* 但实际上GIT是一个内容寻址的文件系统！
* 其核心是一个键值存储
  * 值：加入GIT的数据
  * 键：通过数据内容算出的40个字符SHA-1校验和
  * 前2个字符作为子目录名，后38个字符作为文件名
  * 所有对象均保存在.git/objects目录中（文件内容会被压缩） 
* 是一个“文件系统之上的文件系统

”![git1](图片\git1.png)

”![git2](图片\git2.png)